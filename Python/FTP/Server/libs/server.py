#!/usr/bin/env python# -*- coding:utf-8 -*-"""需修复和优化：1. 异常处理2. 上传和下载3. 多余的交互和逻辑判断4. 代码外观"""import hashlibimport jsonimport osimport socketserverimport structimport subprocessimport sysimport userssys.path.append(os.path.join(os.path.dirname(os.path.dirname(__file__)), 'config'))import configclass Server(socketserver.BaseRequestHandler):    __flag = False    __rscdict = {        0: None,        20: 'User connected',        21: 'User authorized',        22: 'User registered',        23: 'User disconnected',        30: 'Username exist',        31: 'Username does not exist',        32: 'Incorrect password',        33: 'Permission required',        34: 'Arguments required',        35: 'Target path not existed',    }    __usr_accounts = {}    @staticmethod    def __statushandler(rsn):        print('{}: {}'.format(rsn, Server.__rscdict[rsn]))    @staticmethod    def load_usr_accounts():        if os.path.exists(config.USER_ACCOUNTS_FILE):            Server.__usr_accounts = json.load(open(config.USER_ACCOUNTS_FILE, 'r'))        else:            json.dump(Server.__usr_accounts, open(config.USER_ACCOUNTS_FILE, 'w'))    def auth(self, auth_info):        auth_info = json.loads(auth_info)        usr = auth_info["usr"]        # 检查用户是否存在        if usr in Server.__usr_accounts.keys():            if Server.__md5_encrypt(auth_info["pwd"]) == Server.__usr_accounts[usr]["pwd"]:                self.cusr = users.Users(usr)                self.request.sendall(bytes('{}:{}'.format(21, Server.__rscdict[21]), encoding='utf-8'))            else:                self.request.sendall(bytes('{}:{}'.format(32, Server.__rscdict[32]), encoding='utf-8'))        else:            self.request.sendall(bytes('{}:{}'.format(31, Server.__rscdict[31]), encoding='utf-8'))    def cd(self, r_command):        args = r_command.split('cd')        args.remove('')        path = args[0]    def cmd(self, args):        if args:            if 'cd' in args.split()[0] or 'dir' in args.split()[0]:                self.request.sendall(bytes('{}:{}'.format(33, Server.__rscdict[33]), encoding='utf-8'))            else:                self.request.sendall(bytes('{}:{}'.format(0, Server.__rscdict[0]), encoding='utf-8'))                shell_command = '"%s" /c %s' % (os.path.join(os.environ['SYSTEMROOT'], 'system32', 'cmd.exe'), args)                process = subprocess.Popen(shell_command, shell=False, stdout=subprocess.PIPE, stderr=subprocess.PIPE,                                           universal_newlines=True)                output = process.stdout.read()                error = process.stderr.read()                header = struct.pack('i', len(output) + len(error))                self.request.sendall(header)                self.request.sendall(bytes(output, encoding='utf-8'))                self.request.sendall(bytes(error, encoding='utf-8'))        else:            self.request.sendall(bytes('{}:{}'.format(34, Server.__rscdict[34]), encoding='utf-8'))    def command_parse(self, command):        func, args = command.split('|', 1)        func = getattr(self, func)        func(args)    def download(self, command):        pass    def handle(self):        Server.__statushandler(20)        Server.__flag = True        while Server.__flag:            try:                command = self.request.recv(config.BUFFER_SIZE).decode()                if not command or 'exit' in command or 'quit' in command:                    Server.__statushandler(23)                    break                self.command_parse(command)            except ConnectionAbortedError:                print("User {} connection was aborted".format(self.client_address))                break    @staticmethod    def __default_usr_dir(usr):        usr_dir = os.path.join(config.USERSDATA_DIR, usr)        os.makedirs(usr_dir)        usr_config_dir = os.path.join(usr_dir, 'config')        os.makedirs(usr_config_dir)        file = open(os.path.join(usr_config_dir, "config.ini"), 'wb')        file.close()        home_dir = os.path.join(usr_dir, 'home')        os.makedirs(home_dir)    @staticmethod    def __md5_encrypt(pwd):        """        md5加密        :param pwd: 用户密码        :return: 被加密密码的暗文        """        ha = hashlib.md5(bytes('xizt', encoding='utf-8'))        ha.update(bytes(pwd, encoding='utf-8'))        return ha.hexdigest()    def register(self, reg_info):        reg_info = json.loads(reg_info)        usr = reg_info["usr"]        if usr in Server.__usr_accounts.keys():            self.request.sendall(bytes('{}:{}'.format(30, Server.__rscdict[30]), encoding='utf-8'))        else:            encrypted_pwd = Server.__md5_encrypt(reg_info["pwd"])            # 将新用户的信息写入用户信息字典内，并写入用户信息配置文件            Server.__usr_accounts[usr] = {"pwd": encrypted_pwd}            json.dump(Server.__usr_accounts, open(config.USER_ACCOUNTS_FILE, 'w'))            Server.__default_usr_dir(usr)  # 在用户目录下创建默认文件夹和文件            self.request.sendall(bytes('{}:{}'.format(22, Server.__rscdict[22]), encoding='utf-8'))    def receive_handler(self, server_file_path, total_size, has_recv=0, mode="wb"):        """        解决由于重复使用接收数据的循环表达式造成upload函数过于冗杂的问题        :param total_size:        :param has_recv:        :return:        """        file = open(server_file_path, mode=mode)        while has_recv < total_size:            try:                fetch_data = self.request.recv(config.BUFFER_SIZE)                if not fetch_data:                    raise Exception            except Exception:                Server.__flag = False                Server.__statushandler(23)                break            file.write(fetch_data)            has_recv += len(fetch_data)        file.close()    def upload(self, args):        """        可扩展：在不终止双方连接的情况下进行上传暂停        :param args:上传文件的文件名/上传文件的路径；上传至服务器的位置路径        :return:        """        # 如果提供参数为空，报错; 如果提供参数少于2，报错        if not args or len(args.split(' ', 1)) < 1:            # 交互1            self.request.sendall(bytes("{}:{}".format(34, Server.__rscdict[34]), encoding='utf-8'))        else:            # 交互1            self.request.sendall(bytes("{}:{}".format(0, Server.__rscdict[0]), encoding='utf-8'))            # 刷新缓冲区 - 1            self.request.recv(config.BUFFER_SIZE).decode()            # 获得本机文件路径和服务器的路径            client_file_path, server_path = args.split(" ", 1)            # 发送本机文件路径，检查存在性并获取文件大小，交互2            self.request.sendall(bytes(client_file_path, encoding='utf-8'))            # 接收本机文件路径存在性和文件大小，交互3            exist, file_size = self.request.recv(config.BUFFER_SIZE).decode().split("|", 1)            if exist == '1':                # 获取文件名（非路径）                file_name = os.path.basename(client_file_path)                file_size = int(file_size)                # 将服务器定义的路径转换为真正的路径（非文件的路径，文件的路径需要与文件和目标路径拼接）                if server_path == '~':                    target_path = self.cusr.usr_file_path                else:                    target_path = os.path.join(self.cusr.usr_file_path, server_path)                # 检查上传文件的目标路径是否存在                if os.path.exists(target_path):                    # 交互4                    self.request.sendall(bytes("{}:{}".format(0, Server.__rscdict[0]), encoding='utf-8'))                    # 刷新缓冲区 - 2                    self.request.recv(config.BUFFER_SIZE).decode()                    # 获得文件在服务器的路径                    server_file_path = os.path.join(target_path, file_name)                    # 检查要上传的文件是否存在与服务器中                    has_recv = 0                    if os.path.exists(server_file_path):                        # 交互5，上传的文件名存在于服务器中                        self.request.sendall(bytes("3061", encoding='utf-8'))                        # 刷新缓冲区 - 3                        self.request.recv(config.BUFFER_SIZE).decode()                        # 存在，比较其文件大小：相同，不用上传；不相同，重新传或者继续传                        cfile_total_size = os.stat(server_file_path).st_size                        if file_size == cfile_total_size:                            # 告知客户端的所上传的文件已存在并且文件大小相同，不要在上存，交互6                            self.request.sendall(bytes("{}:{}".format(36, Server.__rscdict[36]), encoding='utf-8'))                        else:                            # 交互6                            self.request.sendall(bytes("{}:{}".format(0, Server.__rscdict[0]), encoding='utf-8'))                            # 交互7                            resume = self.request.recv(config.BUFFER_SIZE).decode()                            # 刷新缓冲区 - 4                            self.request.sendall(b'Reset buffer')                            if resume == "3062":                                # 重新上传                                # 交互8，接收并解压头报，以免粘包                                header_struct = self.request.recv(4)                                unpack_header = struct.unpack('i', header_struct)                                total_size = unpack_header[0]                                # 交互9，接收传入数据，写入文件                                self.receive_handler(server_file_path, total_size)                            elif resume == "3063":                                # 续传                                has_recv = cfile_total_size                                # 发送服务器里尚未上传完成的文件的大小，交互8                                self.request.sendall(bytes(str(cfile_total_size), encoding='utf-8'))                                # 交互9，接收数据，续写文件                                self.receive_handler(server_file_path, file_size, has_recv=has_recv, mode="ab")                    else:                        # 不存在，直接传，交互5                        self.request.sendall(bytes("3060", encoding='utf-8'))                        # 接收并解压头报，即文件大小，交互6                        header_struct = self.request.recv(4)                        unpack_header = struct.unpack('i', header_struct)                        total_size = unpack_header[0]                        # 进行数据接收，写入文件，交互7                        self.receive_handler(server_file_path, total_size)                else:                    self.request.sendall(bytes("{}:{}".format(35, Server.__rscdict[35]), encoding='utf-8'))